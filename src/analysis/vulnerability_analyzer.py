"""
Psychological Vulnerability Analyzer - Identifies exploitation patterns
Maps how Facebook identified and exploited psychological vulnerabilities
"""

import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
from collections import defaultdict

from ..models.behavioral_vectors import PsychologicalVulnerability, FacebookPsychProfile


class PsychologicalVulnerabilityMapper:
    """Maps and analyzes psychological vulnerabilities from Facebook data"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Vulnerability detection patterns
        self.VULNERABILITY_PATTERNS = {
            'emotional_vulnerability': {
                'keywords': ['stress', 'anxiety', 'depression', 'sad', 'lonely', 'isolated', 'overwhelmed'],
                'timing_patterns': ['late_night', 'early_morning', 'weekends'],
                'behavioral_indicators': ['increased_posting', 'emotional_language', 'help_seeking']
            },
            'financial_vulnerability': {
                'keywords': ['money', 'debt', 'broke', 'cheap', 'discount', 'save', 'budget'],
                'timing_patterns': ['end_of_month', 'after_holidays', 'tax_season'],
                'behavioral_indicators': ['price_comparison', 'deal_seeking', 'budget_content']
            },
            'social_vulnerability': {
                'keywords': ['alone', 'friends', 'relationship', 'single', 'dating', 'social'],
                'timing_patterns': ['holidays', 'weekends', 'valentines'],
                'behavioral_indicators': ['dating_apps', 'social_events', 'relationship_content']
            },
            'health_vulnerability': {
                'keywords': ['sick', 'pain', 'health', 'doctor', 'medical', 'symptoms'],
                'timing_patterns': ['flu_season', 'after_diagnosis', 'health_scares'],
                'behavioral_indicators': ['health_searches', 'medical_content', 'symptom_checking']
            },
            'professional_vulnerability': {
                'keywords': ['job', 'career', 'unemployed', 'interview', 'resume', 'work'],
                'timing_patterns': ['graduation', 'layoffs', 'career_transitions'],
                'behavioral_indicators': ['job_searching', 'career_content', 'networking']
            }
        }
        
    def identify_vulnerabilities_from_targeting(self, fb_profile: FacebookPsychProfile) -> List[PsychologicalVulnerability]:
        """
        Identify vulnerabilities based on Facebook's targeting patterns
        """
        vulnerabilities = []
        
        # Analyze targeting categories for vulnerability indicators
        for category in fb_profile.targeting_categories:
            vulnerability = self._detect_vulnerability_from_category(category)
            if vulnerability:
                vulnerabilities.append(vulnerability)
                
        # Analyze ad engagement patterns for vulnerability timing
        engagement_vulnerabilities = self._analyze_engagement_vulnerabilities(fb_profile)
        vulnerabilities.extend(engagement_vulnerabilities)
        
        # Analyze vulnerability windows
        for timestamp, description in fb_profile.vulnerability_windows:
            vulnerability = PsychologicalVulnerability(
                vulnerability_type=self._classify_vulnerability_type(description),
                severity=self._assess_vulnerability_severity(description),
                exploitation_method=description,
                timing_patterns=[timestamp.strftime('%Y-%m-%d %H:%M')],
                protective_factors=[],
                facebook_exploitation_evidence=f"Targeted during: {description}"
            )
            vulnerabilities.append(vulnerability)
            
        return self._deduplicate_vulnerabilities(vulnerabilities)
    
    def _detect_vulnerability_from_category(self, category: str) -> Optional[PsychologicalVulnerability]:
        """Detect vulnerability type from targeting category"""
        category_lower = category.lower()
        
        for vuln_type, patterns in self.VULNERABILITY_PATTERNS.items():
            if any(keyword in category_lower for keyword in patterns['keywords']):
                return PsychologicalVulnerability(
                    vulnerability_type=vuln_type,
                    severity=self._assess_category_severity(category),
                    exploitation_method=f"Targeting category: {category}",
                    timing_patterns=[],
                    protective_factors=[],
                    facebook_exploitation_evidence=f"Facebook categorized user with: {category}"
                )
                
        return None
    
    def _analyze_engagement_vulnerabilities(self, fb_profile: FacebookPsychProfile) -> List[PsychologicalVulnerability]:
        """Analyze ad engagements to identify vulnerability exploitation"""
        vulnerabilities = []
        
        # Group engagements by type and frequency
        engagement_analysis = defaultdict(int)
        
        for interaction, count in fb_profile.ad_engagement_patterns.items():
            interaction_lower = interaction.lower()
            
            # High engagement with vulnerability-related content indicates exploitation
            if count > 3:  # Threshold for significant engagement
                for vuln_type, patterns in self.VULNERABILITY_PATTERNS.items():
                    if any(keyword in interaction_lower for keyword in patterns['keywords']):
                        vulnerability = PsychologicalVulnerability(
                            vulnerability_type=vuln_type,
                            severity=min(1.0, count / 10.0),  # Higher engagement = higher severity
                            exploitation_method=f"High engagement with {interaction} ({count} times)",
                            timing_patterns=[],
                            protective_factors=[],
                            facebook_exploitation_evidence=f"Repeatedly engaged with {vuln_type} content"
                        )
                        vulnerabilities.append(vulnerability)
                        
        return vulnerabilities
    
    def _classify_vulnerability_type(self, description: str) -> str:
        """Classify vulnerability type from description"""
        description_lower = description.lower()
        
        for vuln_type, patterns in self.VULNERABILITY_PATTERNS.items():
            if any(keyword in description_lower for keyword in patterns['keywords']):
                return vuln_type
                
        return 'general_vulnerability'
    
    def _assess_vulnerability_severity(self, description: str) -> float:
        """Assess vulnerability severity from description"""
        description_lower = description.lower()
        severity = 0.5  # Base severity
        
        # Increase severity based on intensity words
        intensity_words = {
            'severe': 0.9, 'extreme': 0.9, 'desperate': 0.8, 'crisis': 0.8,
            'urgent': 0.7, 'critical': 0.7, 'serious': 0.6, 'major': 0.6,
            'moderate': 0.4, 'mild': 0.3, 'slight': 0.2
        }
        
        for word, score in intensity_words.items():
            if word in description_lower:
                severity = max(severity, score)
                break
                
        return min(1.0, severity)
    
    def _assess_category_severity(self, category: str) -> float:
        """Assess vulnerability severity from targeting category"""
        category_lower = category.lower()
        
        # High-risk categories
        high_risk = ['crisis', 'emergency', 'urgent', 'desperate', 'struggling']
        medium_risk = ['stress', 'anxiety', 'worry', 'concern', 'difficulty']
        low_risk = ['interest', 'hobby', 'casual', 'general']
        
        if any(word in category_lower for word in high_risk):
            return 0.8
        elif any(word in category_lower for word in medium_risk):
            return 0.6
        elif any(word in category_lower for word in low_risk):
            return 0.3
            
        return 0.5  # Default severity
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[PsychologicalVulnerability]) -> List[PsychologicalVulnerability]:
        """Remove duplicate vulnerabilities and merge similar ones"""
        unique_vulnerabilities = {}
        
        for vuln in vulnerabilities:
            key = vuln.vulnerability_type
            
            if key in unique_vulnerabilities:
                # Merge with existing vulnerability
                existing = unique_vulnerabilities[key]
                existing.severity = max(existing.severity, vuln.severity)
                existing.timing_patterns.extend(vuln.timing_patterns)
                existing.protective_factors.extend(vuln.protective_factors)
                existing.facebook_exploitation_evidence += f"; {vuln.facebook_exploitation_evidence}"
            else:
                unique_vulnerabilities[key] = vuln
                
        return list(unique_vulnerabilities.values())
    
    def analyze_vulnerability_timing(self, vulnerabilities: List[PsychologicalVulnerability],
                                   activity_timeline: List[Dict]) -> Dict[str, List[str]]:
        """
        Analyze when vulnerabilities were exploited based on activity timeline
        """
        timing_analysis = defaultdict(list)
        
        for vuln in vulnerabilities:
            vuln_type = vuln.vulnerability_type
            
            # Analyze timing patterns from vulnerability
            for timing_pattern in vuln.timing_patterns:
                if timing_pattern:
                    try:
                        timestamp = datetime.fromisoformat(timing_pattern.replace('Z', '+00:00'))
                        hour = timestamp.hour
                        day_of_week = timestamp.strftime('%A')
                        
                        # Identify vulnerable time periods
                        if hour < 6 or hour > 22:  # Late night/early morning
                            timing_analysis[vuln_type].append('vulnerable_hours')
                        if day_of_week in ['Saturday', 'Sunday']:
                            timing_analysis[vuln_type].append('weekends')
                        if timestamp.day > 25:  # End of month
                            timing_analysis[vuln_type].append('month_end')
                            
                    except (ValueError, AttributeError):
                        continue
                        
        return dict(timing_analysis)
    
    def generate_vulnerability_protection_plan(self, vulnerabilities: List[PsychologicalVulnerability]) -> Dict[str, List[str]]:
        """
        Generate personalized protection strategies for identified vulnerabilities
        """
        protection_plan = {}
        
        for vuln in vulnerabilities:
            vuln_type = vuln.vulnerability_type
            protection_strategies = []
            
            if vuln_type == 'emotional_vulnerability':
                protection_strategies.extend([
                    "Create emotional awareness checkpoints before making decisions",
                    "Establish support network for emotional validation",
                    "Implement 24-hour cooling-off period for emotional decisions",
                    "Use emotion regulation techniques (deep breathing, mindfulness)"
                ])
                
            elif vuln_type == 'financial_vulnerability':
                protection_strategies.extend([
                    "Set strict monthly spending limits and track expenses",
                    "Implement mandatory waiting periods for non-essential purchases",
                    "Create emergency fund to reduce financial stress",
                    "Seek financial counseling or budgeting assistance"
                ])
                
            elif vuln_type == 'social_vulnerability':
                protection_strategies.extend([
                    "Build genuine social connections outside social media",
                    "Practice self-validation independent of social approval",
                    "Limit social media comparison behaviors",
                    "Engage in community activities and volunteering"
                ])
                
            elif vuln_type == 'health_vulnerability':
                protection_strategies.extend([
                    "Consult healthcare professionals for medical decisions",
                    "Avoid self-diagnosis from online content",
                    "Create trusted health information sources list",
                    "Practice health anxiety management techniques"
                ])
                
            elif vuln_type == 'professional_vulnerability':
                protection_strategies.extend([
                    "Develop multiple income streams and skills",
                    "Build professional network through genuine relationships",
                    "Avoid desperation-driven career decisions",
                    "Seek career counseling and mentorship"
                ])
                
            # Add timing-specific protections
            if vuln.timing_patterns:
                protection_strategies.append("Be extra cautious during identified vulnerable time periods")
                protection_strategies.append("Set up accountability partners for high-risk times")
                
            protection_plan[vuln_type] = protection_strategies
            
        return protection_plan
    
    def calculate_exploitation_success_rate(self, vulnerabilities: List[PsychologicalVulnerability],
                                          fb_profile: FacebookPsychProfile) -> Dict[str, float]:
        """
        Calculate how successfully Facebook exploited each vulnerability type
        """
        success_rates = {}
        
        for vuln in vulnerabilities:
            vuln_type = vuln.vulnerability_type
            
            # Calculate success rate based on engagement patterns
            related_engagements = 0
            total_opportunities = 0
            
            for interaction, count in fb_profile.ad_engagement_patterns.items():
                if any(keyword in interaction.lower() 
                      for keyword in self.VULNERABILITY_PATTERNS.get(vuln_type, {}).get('keywords', [])):
                    related_engagements += count
                    total_opportunities += count + 1  # Assume some ads were shown but not engaged with
                    
            if total_opportunities > 0:
                success_rates[vuln_type] = related_engagements / total_opportunities
            else:
                success_rates[vuln_type] = 0.0
                
        return success_rates
